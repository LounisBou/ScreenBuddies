# Phase 5.4: Auth Provider

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Create Riverpod auth provider with login, register, and logout functionality.

**Architecture:** StateNotifier pattern with AuthState. Handles token persistence and user fetching.

**Tech Stack:** Riverpod 2.x, StateNotifier

**Prerequisites:** Phase 5.3 complete

**Reference:** `docs/plans/phase-5-flutter-foundation.md` Task 6

---

## Task 1: Create User Model

**Step 1: Create user_model.dart**

Create `frontend/lib/data/models/user_model.dart`:
```dart
import 'package:equatable/equatable.dart';

class User extends Equatable {
  final int id;
  final String email;
  final String? displayName;
  final String? avatarUrl;
  final bool emailVerified;
  final String locale;
  final bool notifEmail;
  final bool notifPush;
  final DateTime createdAt;

  const User({
    required this.id,
    required this.email,
    this.displayName,
    this.avatarUrl,
    required this.emailVerified,
    required this.locale,
    required this.notifEmail,
    required this.notifPush,
    required this.createdAt,
  });

  factory User.fromJson(Map<String, dynamic> json) {
    return User(
      id: json['id'] as int,
      email: json['email'] as String,
      displayName: json['display_name'] as String?,
      avatarUrl: json['avatar_url'] as String?,
      emailVerified: json['email_verified'] as bool,
      locale: json['locale'] as String? ?? 'en',
      notifEmail: json['notif_email'] as bool? ?? true,
      notifPush: json['notif_push'] as bool? ?? true,
      createdAt: DateTime.parse(json['created_at'] as String),
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'id': id,
      'email': email,
      'display_name': displayName,
      'avatar_url': avatarUrl,
      'email_verified': emailVerified,
      'locale': locale,
      'notif_email': notifEmail,
      'notif_push': notifPush,
      'created_at': createdAt.toIso8601String(),
    };
  }

  String get displayNameOrEmail => displayName ?? email.split('@').first;

  User copyWith({
    int? id,
    String? email,
    String? displayName,
    String? avatarUrl,
    bool? emailVerified,
    String? locale,
    bool? notifEmail,
    bool? notifPush,
    DateTime? createdAt,
  }) {
    return User(
      id: id ?? this.id,
      email: email ?? this.email,
      displayName: displayName ?? this.displayName,
      avatarUrl: avatarUrl ?? this.avatarUrl,
      emailVerified: emailVerified ?? this.emailVerified,
      locale: locale ?? this.locale,
      notifEmail: notifEmail ?? this.notifEmail,
      notifPush: notifPush ?? this.notifPush,
      createdAt: createdAt ?? this.createdAt,
    );
  }

  @override
  List<Object?> get props => [
        id,
        email,
        displayName,
        avatarUrl,
        emailVerified,
        locale,
        notifEmail,
        notifPush,
        createdAt,
      ];
}

class AuthTokens {
  final String accessToken;
  final String refreshToken;
  final int expiresIn;

  const AuthTokens({
    required this.accessToken,
    required this.refreshToken,
    required this.expiresIn,
  });

  factory AuthTokens.fromJson(Map<String, dynamic> json) {
    return AuthTokens(
      accessToken: json['access_token'] as String,
      refreshToken: json['refresh_token'] as String,
      expiresIn: json['expires_in'] as int,
    );
  }
}
```

**Step 2: Commit**

```bash
cd /Users/lounis/dev/ScreenBuddies
git add frontend/lib/data/models/user_model.dart
git commit -m "feat: add User and AuthTokens models"
```

---

## Task 2: Create Auth Provider

**Step 1: Create auth_provider.dart**

Create `frontend/lib/presentation/providers/auth_provider.dart`:
```dart
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../../core/errors/api_exception.dart';
import '../../data/cache/hive_cache.dart';
import '../../data/datasources/local/secure_storage.dart';
import '../../data/datasources/remote/api_client.dart';
import '../../data/models/user_model.dart';

// Secure storage provider
final secureStorageProvider = Provider((ref) => SecureStorage());

// API client provider
final apiClientProvider = Provider((ref) {
  final storage = ref.read(secureStorageProvider);
  return ApiClient(ref, storage);
});

// Auth status enum
enum AuthStatus {
  unknown,
  authenticated,
  unauthenticated,
}

// Auth state
class AuthState {
  final AuthStatus status;
  final User? user;
  final bool isLoading;
  final String? error;

  const AuthState({
    this.status = AuthStatus.unknown,
    this.user,
    this.isLoading = false,
    this.error,
  });

  bool get isAuthenticated => status == AuthStatus.authenticated;
  bool get isUnauthenticated => status == AuthStatus.unauthenticated;
  bool get isUnknown => status == AuthStatus.unknown;

  AuthState copyWith({
    AuthStatus? status,
    User? user,
    bool clearUser = false,
    bool? isLoading,
    String? error,
    bool clearError = false,
  }) {
    return AuthState(
      status: status ?? this.status,
      user: clearUser ? null : (user ?? this.user),
      isLoading: isLoading ?? this.isLoading,
      error: clearError ? null : (error ?? this.error),
    );
  }
}

// Auth notifier
class AuthNotifier extends StateNotifier<AuthState> {
  final ApiClient _apiClient;
  final SecureStorage _storage;

  AuthNotifier(this._apiClient, this._storage) : super(const AuthState()) {
    _checkAuthStatus();
  }

  Future<void> _checkAuthStatus() async {
    final hasTokens = await _storage.hasTokens();
    if (hasTokens) {
      try {
        await _loadUser();
      } catch (_) {
        await _storage.clearTokens();
        state = state.copyWith(status: AuthStatus.unauthenticated);
      }
    } else {
      state = state.copyWith(status: AuthStatus.unauthenticated);
    }
  }

  Future<void> _loadUser() async {
    final response = await _apiClient.get<Map<String, dynamic>>('/me');
    final user = User.fromJson(response['data'] as Map<String, dynamic>);
    state = state.copyWith(
      status: AuthStatus.authenticated,
      user: user,
    );
  }

  Future<void> login(String email, String password) async {
    state = state.copyWith(isLoading: true, clearError: true);

    try {
      final response = await _apiClient.post<Map<String, dynamic>>(
        '/auth/login',
        data: {'email': email, 'password': password},
      );

      final data = response['data'] as Map<String, dynamic>;
      final user = User.fromJson(data['user'] as Map<String, dynamic>);
      final tokens = AuthTokens.fromJson(data['tokens'] as Map<String, dynamic>);

      await _storage.saveTokens(
        accessToken: tokens.accessToken,
        refreshToken: tokens.refreshToken,
      );

      state = state.copyWith(
        status: AuthStatus.authenticated,
        user: user,
        isLoading: false,
      );
    } on ApiException catch (e) {
      state = state.copyWith(isLoading: false, error: e.message);
      rethrow;
    } catch (e) {
      state = state.copyWith(
        isLoading: false,
        error: 'An unexpected error occurred',
      );
      rethrow;
    }
  }

  Future<void> register({
    required String email,
    required String password,
    String? displayName,
    String locale = 'en',
  }) async {
    state = state.copyWith(isLoading: true, clearError: true);

    try {
      final response = await _apiClient.post<Map<String, dynamic>>(
        '/auth/register',
        data: {
          'email': email,
          'password': password,
          'password_confirmation': password,
          if (displayName != null && displayName.isNotEmpty)
            'display_name': displayName,
          'locale': locale,
        },
      );

      final data = response['data'] as Map<String, dynamic>;
      final user = User.fromJson(data['user'] as Map<String, dynamic>);
      final tokens = AuthTokens.fromJson(data['tokens'] as Map<String, dynamic>);

      await _storage.saveTokens(
        accessToken: tokens.accessToken,
        refreshToken: tokens.refreshToken,
      );

      state = state.copyWith(
        status: AuthStatus.authenticated,
        user: user,
        isLoading: false,
      );
    } on ApiException catch (e) {
      state = state.copyWith(isLoading: false, error: e.message);
      rethrow;
    } catch (e) {
      state = state.copyWith(
        isLoading: false,
        error: 'An unexpected error occurred',
      );
      rethrow;
    }
  }

  Future<void> logout() async {
    state = state.copyWith(isLoading: true);

    try {
      await _apiClient.post('/auth/logout');
    } catch (_) {
      // Ignore logout API errors
    }

    await _storage.clearTokens();
    await HiveCache.clearUserData();

    state = const AuthState(status: AuthStatus.unauthenticated);
  }

  Future<void> refreshUser() async {
    try {
      await _loadUser();
    } catch (_) {
      // Keep current user data if refresh fails
    }
  }

  void clearError() {
    state = state.copyWith(clearError: true);
  }
}

// Provider
final authProvider = StateNotifierProvider<AuthNotifier, AuthState>((ref) {
  final apiClient = ref.read(apiClientProvider);
  final storage = ref.read(secureStorageProvider);
  return AuthNotifier(apiClient, storage);
});

// Convenience providers
final isAuthenticatedProvider = Provider<bool>((ref) {
  return ref.watch(authProvider).isAuthenticated;
});

final currentUserProvider = Provider<User?>((ref) {
  return ref.watch(authProvider).user;
});
```

**Step 2: Commit**

```bash
git add frontend/lib/presentation/providers/auth_provider.dart
git commit -m "feat: add auth provider with login/register/logout"
```

---

## Auth State Diagram

```
┌─────────────────────────────────────────────────┐
│              AuthStatus.unknown                  │
│         (App startup, checking tokens)           │
└─────────────────┬───────────────────────────────┘
                  │
        ┌─────────┴─────────┐
        │ hasTokens()       │
        │                   │
        ▼                   ▼
    ┌─────────┐       ┌─────────────┐
    │  true   │       │   false     │
    └────┬────┘       └──────┬──────┘
         │                   │
         ▼                   │
┌─────────────────┐          │
│  Fetch /me      │          │
└────────┬────────┘          │
         │                   │
    ┌────┴────┐              │
    │         │              │
    ▼         ▼              ▼
┌──────┐  ┌──────┐   ┌───────────────────────────┐
│ 200  │  │ 401  │   │ AuthStatus.unauthenticated │
│ OK   │  │      │   └───────────────────────────┘
└──┬───┘  └──┬───┘
   │         │
   ▼         ▼
┌──────────────────────┐
│AuthStatus.authenticated│
│     user: User        │
└──────────────────────┘
```

---

## API Response Formats

**Login Response:**
```json
{
  "data": {
    "user": {
      "id": 1,
      "email": "user@example.com",
      "display_name": "User",
      "email_verified": true,
      "locale": "en",
      "notif_email": true,
      "notif_push": true,
      "created_at": "2024-01-01T00:00:00Z"
    },
    "tokens": {
      "access_token": "...",
      "refresh_token": "...",
      "expires_in": 900
    }
  }
}
```

**Me Response:**
```json
{
  "data": {
    "id": 1,
    "email": "user@example.com",
    "display_name": "User",
    "email_verified": true,
    "locale": "en",
    "notif_email": true,
    "notif_push": true,
    "created_at": "2024-01-01T00:00:00Z"
  }
}
```

---

## Phase 5.4 Completion Checklist

- [ ] user_model.dart with User and AuthTokens
- [ ] auth_provider.dart with StateNotifier
- [ ] secureStorageProvider
- [ ] apiClientProvider
- [ ] authProvider with AuthNotifier
- [ ] login() method
- [ ] register() method
- [ ] logout() method with cache clear
- [ ] refreshUser() method
- [ ] Convenience providers (isAuthenticated, currentUser)
- [ ] All changes committed

---

## Next Sub-Phase

Proceed to **Phase 5.5: Router** for navigation setup.
