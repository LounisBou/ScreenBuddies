# Phase 5.3: API Client & Storage

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Create Dio HTTP client with interceptors, secure token storage, and Hive offline cache.

**Architecture:** API client with auth interceptor, automatic token refresh, error handling. Hive for offline caching.

**Tech Stack:** Dio, flutter_secure_storage, Hive, connectivity_plus

**Prerequisites:** Phase 5.2 complete

**Reference:** `docs/plans/phase-5-flutter-foundation.md` Tasks 5, 5.5

---

## Task 1: Create API Exception

**Step 1: Create api_exception.dart**

Create `frontend/lib/core/errors/api_exception.dart`:
```dart
class ApiException implements Exception {
  final String code;
  final String message;
  final int statusCode;
  final Map<String, dynamic>? details;

  ApiException({
    required this.code,
    required this.message,
    required this.statusCode,
    this.details,
  });

  factory ApiException.fromJson(Map<String, dynamic> json, int statusCode) {
    final error = json['error'] as Map<String, dynamic>?;
    return ApiException(
      code: error?['code'] ?? 'UNKNOWN_ERROR',
      message: error?['message'] ?? 'An unknown error occurred',
      statusCode: statusCode,
      details: error?['details'] as Map<String, dynamic>?,
    );
  }

  bool get isUnauthorized => statusCode == 401;
  bool get isForbidden => statusCode == 403;
  bool get isNotFound => statusCode == 404;
  bool get isValidationError => statusCode == 422;
  bool get isServerError => statusCode >= 500;

  @override
  String toString() => 'ApiException: [$code] $message';
}

class NetworkException implements Exception {
  final String message;

  NetworkException(this.message);

  @override
  String toString() => 'NetworkException: $message';
}
```

**Step 2: Commit**

```bash
cd /Users/lounis/dev/ScreenBuddies
git add frontend/lib/core/errors/api_exception.dart
git commit -m "feat: add API exception classes"
```

---

## Task 2: Create Secure Storage

**Step 1: Create secure_storage.dart**

Create `frontend/lib/data/datasources/local/secure_storage.dart`:
```dart
import 'package:flutter_secure_storage/flutter_secure_storage.dart';

class SecureStorage {
  static const _storage = FlutterSecureStorage(
    aOptions: AndroidOptions(encryptedSharedPreferences: true),
    iOptions: IOSOptions(accessibility: KeychainAccessibility.first_unlock),
  );

  static const _accessTokenKey = 'access_token';
  static const _refreshTokenKey = 'refresh_token';

  Future<void> saveTokens({
    required String accessToken,
    required String refreshToken,
  }) async {
    await Future.wait([
      _storage.write(key: _accessTokenKey, value: accessToken),
      _storage.write(key: _refreshTokenKey, value: refreshToken),
    ]);
  }

  Future<String?> getAccessToken() async {
    return _storage.read(key: _accessTokenKey);
  }

  Future<String?> getRefreshToken() async {
    return _storage.read(key: _refreshTokenKey);
  }

  Future<void> clearTokens() async {
    await Future.wait([
      _storage.delete(key: _accessTokenKey),
      _storage.delete(key: _refreshTokenKey),
    ]);
  }

  Future<bool> hasTokens() async {
    final token = await getAccessToken();
    return token != null && token.isNotEmpty;
  }
}
```

**Step 2: Commit**

```bash
git add frontend/lib/data/datasources/local/secure_storage.dart
git commit -m "feat: add secure token storage"
```

---

## Task 3: Create API Client

**Step 1: Create api_client.dart**

Create `frontend/lib/data/datasources/remote/api_client.dart`:
```dart
import 'package:dio/dio.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../../../core/config/app_config.dart';
import '../../../core/errors/api_exception.dart';
import '../local/secure_storage.dart';

class ApiClient {
  late final Dio _dio;
  final SecureStorage _storage;
  final Ref _ref;
  bool _isRefreshing = false;

  ApiClient(this._ref, this._storage) {
    _dio = Dio(BaseOptions(
      baseUrl: AppConfig.baseUrl,
      connectTimeout: const Duration(seconds: 30),
      receiveTimeout: const Duration(seconds: 30),
      headers: {
        'Accept': 'application/json',
        'Content-Type': 'application/json',
      },
    ));

    _dio.interceptors.add(InterceptorsWrapper(
      onRequest: _onRequest,
      onError: _onError,
    ));
  }

  Future<void> _onRequest(
    RequestOptions options,
    RequestInterceptorHandler handler,
  ) async {
    final token = await _storage.getAccessToken();
    if (token != null) {
      options.headers['Authorization'] = 'Bearer $token';
    }
    handler.next(options);
  }

  Future<void> _onError(
    DioException error,
    ErrorInterceptorHandler handler,
  ) async {
    if (error.response?.statusCode == 401 && !_isRefreshing) {
      _isRefreshing = true;
      try {
        final refreshed = await _tryRefreshToken();
        if (refreshed) {
          // Retry original request
          final response = await _retry(error.requestOptions);
          _isRefreshing = false;
          return handler.resolve(response);
        }
      } catch (_) {
        // Refresh failed
      }
      _isRefreshing = false;
    }
    handler.next(error);
  }

  Future<bool> _tryRefreshToken() async {
    try {
      final refreshToken = await _storage.getRefreshToken();
      if (refreshToken == null) return false;

      // Use a separate Dio instance to avoid interceptor loop
      final response = await Dio().post(
        '${AppConfig.baseUrl}/auth/refresh',
        data: {'refresh_token': refreshToken},
        options: Options(headers: {'Accept': 'application/json'}),
      );

      final data = response.data['data'] as Map<String, dynamic>;
      await _storage.saveTokens(
        accessToken: data['access_token'] as String,
        refreshToken: data['refresh_token'] as String,
      );
      return true;
    } catch (_) {
      await _storage.clearTokens();
      return false;
    }
  }

  Future<Response> _retry(RequestOptions requestOptions) async {
    final token = await _storage.getAccessToken();
    final options = Options(
      method: requestOptions.method,
      headers: {
        ...requestOptions.headers,
        'Authorization': 'Bearer $token',
      },
    );

    return _dio.request(
      requestOptions.path,
      data: requestOptions.data,
      queryParameters: requestOptions.queryParameters,
      options: options,
    );
  }

  ApiException _handleError(DioException e) {
    if (e.type == DioExceptionType.connectionTimeout ||
        e.type == DioExceptionType.receiveTimeout) {
      return ApiException(
        code: 'TIMEOUT',
        message: 'Connection timed out. Please try again.',
        statusCode: 408,
      );
    }

    if (e.type == DioExceptionType.connectionError) {
      throw NetworkException('No internet connection');
    }

    if (e.response?.data != null && e.response!.data is Map) {
      return ApiException.fromJson(
        e.response!.data as Map<String, dynamic>,
        e.response!.statusCode ?? 500,
      );
    }

    return ApiException(
      code: 'NETWORK_ERROR',
      message: e.message ?? 'Network error occurred',
      statusCode: e.response?.statusCode ?? 500,
    );
  }

  // HTTP Methods

  Future<T> get<T>(
    String path, {
    Map<String, dynamic>? queryParameters,
  }) async {
    try {
      final response = await _dio.get(path, queryParameters: queryParameters);
      return response.data as T;
    } on DioException catch (e) {
      throw _handleError(e);
    }
  }

  Future<T> post<T>(
    String path, {
    dynamic data,
    Map<String, dynamic>? queryParameters,
  }) async {
    try {
      final response = await _dio.post(
        path,
        data: data,
        queryParameters: queryParameters,
      );
      return response.data as T;
    } on DioException catch (e) {
      throw _handleError(e);
    }
  }

  Future<T> put<T>(
    String path, {
    dynamic data,
  }) async {
    try {
      final response = await _dio.put(path, data: data);
      return response.data as T;
    } on DioException catch (e) {
      throw _handleError(e);
    }
  }

  Future<T> patch<T>(
    String path, {
    dynamic data,
  }) async {
    try {
      final response = await _dio.patch(path, data: data);
      return response.data as T;
    } on DioException catch (e) {
      throw _handleError(e);
    }
  }

  Future<void> delete(String path) async {
    try {
      await _dio.delete(path);
    } on DioException catch (e) {
      throw _handleError(e);
    }
  }
}
```

**Step 2: Commit**

```bash
git add frontend/lib/data/datasources/remote/api_client.dart
git commit -m "feat: add API client with Dio and interceptors"
```

---

## Task 4: Create Connectivity Service

**Step 1: Create connectivity_service.dart**

Create `frontend/lib/core/services/connectivity_service.dart`:
```dart
import 'package:connectivity_plus/connectivity_plus.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

final connectivityServiceProvider = Provider<ConnectivityService>((ref) {
  return ConnectivityService();
});

final isOnlineProvider = StreamProvider<bool>((ref) {
  return ref.read(connectivityServiceProvider).onConnectivityChanged;
});

class ConnectivityService {
  final _connectivity = Connectivity();

  Stream<bool> get onConnectivityChanged =>
      _connectivity.onConnectivityChanged.map(
        (results) => results.isNotEmpty &&
            !results.contains(ConnectivityResult.none),
      );

  Future<bool> get isOnline async {
    final results = await _connectivity.checkConnectivity();
    return results.isNotEmpty && !results.contains(ConnectivityResult.none);
  }
}
```

**Step 2: Commit**

```bash
git add frontend/lib/core/services/connectivity_service.dart
git commit -m "feat: add connectivity service"
```

---

## Task 5: Create Hive Cache

**Step 1: Create hive_cache.dart**

Create `frontend/lib/data/cache/hive_cache.dart`:
```dart
import 'package:hive_flutter/hive_flutter.dart';

class HiveCache {
  static const String electionsBox = 'elections';
  static const String electionDetailsBox = 'election_details';
  static const String candidatesBox = 'candidates';
  static const String resultsBox = 'results';
  static const String userVotesBox = 'user_votes';
  static const String pendingVotesBox = 'pending_votes';

  static Future<void> init() async {
    await Hive.initFlutter();

    // Open boxes
    await Future.wait([
      Hive.openBox(electionsBox),
      Hive.openBox(electionDetailsBox),
      Hive.openBox(candidatesBox),
      Hive.openBox(resultsBox),
      Hive.openBox(userVotesBox),
      Hive.openBox(pendingVotesBox),
    ]);
  }

  // Elections list cache
  static Future<void> cacheElections(List<Map<String, dynamic>> elections) async {
    final box = Hive.box(electionsBox);
    await box.put('data', elections);
    await box.put('cached_at', DateTime.now().toIso8601String());
  }

  static List<Map<String, dynamic>>? getCachedElections() {
    final box = Hive.box(electionsBox);
    final data = box.get('data');
    if (data == null) return null;
    return List<Map<String, dynamic>>.from(
      (data as List).map((e) => Map<String, dynamic>.from(e)),
    );
  }

  static DateTime? getElectionsCachedAt() {
    final box = Hive.box(electionsBox);
    final cachedAt = box.get('cached_at');
    return cachedAt != null ? DateTime.parse(cachedAt) : null;
  }

  static bool isElectionsCacheValid({Duration maxAge = const Duration(minutes: 5)}) {
    final cachedAt = getElectionsCachedAt();
    if (cachedAt == null) return false;
    return DateTime.now().difference(cachedAt) < maxAge;
  }

  // Election details cache
  static Future<void> cacheElectionDetails(
    String uuid,
    Map<String, dynamic> details,
  ) async {
    final box = Hive.box(electionDetailsBox);
    await box.put(uuid, {
      'data': details,
      'cached_at': DateTime.now().toIso8601String(),
    });
  }

  static Map<String, dynamic>? getCachedElectionDetails(String uuid) {
    final box = Hive.box(electionDetailsBox);
    final cached = box.get(uuid);
    if (cached == null) return null;
    return Map<String, dynamic>.from(cached['data']);
  }

  // Pending votes (offline queue)
  static Future<void> addPendingVote(Map<String, dynamic> vote) async {
    final box = Hive.box(pendingVotesBox);
    final pending = getPendingVotes();
    pending.add(vote);
    await box.put('votes', pending);
  }

  static List<Map<String, dynamic>> getPendingVotes() {
    final box = Hive.box(pendingVotesBox);
    final data = box.get('votes');
    if (data == null) return [];
    return List<Map<String, dynamic>>.from(
      (data as List).map((e) => Map<String, dynamic>.from(e)),
    );
  }

  static Future<void> clearPendingVotes() async {
    final box = Hive.box(pendingVotesBox);
    await box.delete('votes');
  }

  static Future<void> removePendingVote(int index) async {
    final pending = getPendingVotes();
    if (index < pending.length) {
      pending.removeAt(index);
      final box = Hive.box(pendingVotesBox);
      await box.put('votes', pending);
    }
  }

  // Clear all cache
  static Future<void> clearAll() async {
    await Future.wait([
      Hive.box(electionsBox).clear(),
      Hive.box(electionDetailsBox).clear(),
      Hive.box(candidatesBox).clear(),
      Hive.box(resultsBox).clear(),
      Hive.box(userVotesBox).clear(),
      Hive.box(pendingVotesBox).clear(),
    ]);
  }

  // Clear user-specific data (on logout)
  static Future<void> clearUserData() async {
    await Future.wait([
      Hive.box(userVotesBox).clear(),
      Hive.box(pendingVotesBox).clear(),
    ]);
  }
}
```

**Step 2: Commit**

```bash
git add frontend/lib/data/cache/hive_cache.dart
git commit -m "feat: add Hive cache for offline support"
```

---

## API Client Flow

```
┌─────────────────────────────────────────────────┐
│                   Request                        │
└─────────────────┬───────────────────────────────┘
                  │
                  ▼
┌─────────────────────────────────────────────────┐
│         onRequest Interceptor                    │
│    - Add Authorization header                    │
└─────────────────┬───────────────────────────────┘
                  │
                  ▼
┌─────────────────────────────────────────────────┐
│              API Server                          │
└─────────────────┬───────────────────────────────┘
                  │
         ┌────────┴────────┐
         │                 │
         ▼                 ▼
    ┌─────────┐      ┌─────────┐
    │ Success │      │  401    │
    └────┬────┘      └────┬────┘
         │                │
         │                ▼
         │     ┌──────────────────┐
         │     │ Try Refresh Token│
         │     └────────┬─────────┘
         │              │
         │      ┌───────┴───────┐
         │      │               │
         │      ▼               ▼
         │  ┌───────┐     ┌───────┐
         │  │ OK    │     │ Fail  │
         │  │ Retry │     │ Clear │
         │  └───┬───┘     │Tokens │
         │      │         └───────┘
         │      │
         ▼      ▼
┌─────────────────────────────────────────────────┐
│              Return Response                     │
└─────────────────────────────────────────────────┘
```

---

## Phase 5.3 Completion Checklist

- [ ] api_exception.dart with error classes
- [ ] secure_storage.dart for token storage
- [ ] api_client.dart with Dio and interceptors
- [ ] Automatic token refresh on 401
- [ ] connectivity_service.dart for online/offline detection
- [ ] hive_cache.dart for offline caching
- [ ] Pending votes queue for offline voting
- [ ] All changes committed

---

## Next Sub-Phase

Proceed to **Phase 5.4: Auth Provider** for authentication state management.
