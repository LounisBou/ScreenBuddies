# Phase 6.4: Voting Provider

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Create provider for loading duels and casting votes.

**Architecture:** StateNotifier.family keyed by election UUID for per-election voting state.

**Tech Stack:** Riverpod 2.x, Dio

**Prerequisites:** Phase 6.3 complete

**Reference:** `docs/plans/phase-6-flutter-election-features.md` Task 4

---

## Task 1: Create Voting Provider

**Step 1: Create voting_provider.dart**

Create `frontend/lib/presentation/providers/voting_provider.dart`:
```dart
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../../data/cache/hive_cache.dart';
import '../../data/models/candidate_model.dart';
import '../../data/models/duel_model.dart';
import '../../core/services/connectivity_service.dart';
import 'auth_provider.dart';

// Voting state
class VotingState {
  final Duel? currentDuel;
  final bool isComplete;
  final bool isLoading;
  final bool isVoting;
  final String? error;
  final int? lastVotedWinnerId;

  const VotingState({
    this.currentDuel,
    this.isComplete = false,
    this.isLoading = false,
    this.isVoting = false,
    this.error,
    this.lastVotedWinnerId,
  });

  bool get hasDuel => currentDuel != null;
  bool get canVote => hasDuel && !isVoting && !isComplete;

  VotingState copyWith({
    Duel? currentDuel,
    bool clearDuel = false,
    bool? isComplete,
    bool? isLoading,
    bool? isVoting,
    String? error,
    bool clearError = false,
    int? lastVotedWinnerId,
    bool clearLastVoted = false,
  }) {
    return VotingState(
      currentDuel: clearDuel ? null : (currentDuel ?? this.currentDuel),
      isComplete: isComplete ?? this.isComplete,
      isLoading: isLoading ?? this.isLoading,
      isVoting: isVoting ?? this.isVoting,
      error: clearError ? null : (error ?? this.error),
      lastVotedWinnerId:
          clearLastVoted ? null : (lastVotedWinnerId ?? this.lastVotedWinnerId),
    );
  }
}

// Voting notifier (per election)
class VotingNotifier extends StateNotifier<VotingState> {
  final Ref _ref;
  final String _electionUuid;

  VotingNotifier(this._ref, this._electionUuid) : super(const VotingState()) {
    loadNextDuel();
  }

  /// Load the next duel to vote on
  Future<void> loadNextDuel() async {
    state = state.copyWith(isLoading: true, clearError: true);

    try {
      final apiClient = _ref.read(apiClientProvider);
      final response = await apiClient.get<Map<String, dynamic>>(
        '/elections/$_electionUuid/vote/next',
      );

      final data = response['data'];

      if (data == null) {
        // No more duels - voting complete
        state = state.copyWith(
          isComplete: true,
          isLoading: false,
          clearDuel: true,
        );
        return;
      }

      final duel = Duel.fromJson(data as Map<String, dynamic>);
      state = state.copyWith(
        currentDuel: duel,
        isLoading: false,
        isComplete: false,
      );
    } catch (e) {
      state = state.copyWith(
        isLoading: false,
        error: e.toString(),
      );
    }
  }

  /// Cast a vote for a candidate
  Future<void> vote(int winnerId) async {
    await _submitVote(winnerId);
  }

  /// Skip the current duel (no preference)
  Future<void> skip() async {
    await _submitVote(null);
  }

  Future<void> _submitVote(int? winnerId) async {
    final duel = state.currentDuel;
    if (duel == null) return;

    // Check if online
    final isOnline = await _ref.read(connectivityServiceProvider).isOnline;
    if (!isOnline) {
      // Queue the vote for later
      await _queueOfflineVote(
        candidateAId: duel.candidateA.id,
        candidateBId: duel.candidateB.id,
        winnerId: winnerId,
      );
      state = state.copyWith(error: 'Vote queued - will sync when online');
      return;
    }

    state = state.copyWith(
      isVoting: true,
      clearError: true,
      lastVotedWinnerId: winnerId,
    );

    try {
      final apiClient = _ref.read(apiClientProvider);
      final response = await apiClient.post<Map<String, dynamic>>(
        '/elections/$_electionUuid/vote',
        data: {
          'candidate_a_id': duel.candidateA.id,
          'candidate_b_id': duel.candidateB.id,
          'winner_id': winnerId, // null for skip
        },
      );

      final data = response['data'] as Map<String, dynamic>;
      final nextDuelData = data['next_duel'];

      if (nextDuelData == null) {
        // No more duels - voting complete
        state = state.copyWith(
          isComplete: true,
          isVoting: false,
          clearDuel: true,
          clearLastVoted: true,
        );
        return;
      }

      // Build the next duel
      final progress = DuelProgress.fromJson(
        data['progress'] as Map<String, dynamic>,
      );
      final nextDuel = Duel(
        candidateA: Candidate.fromJson(
          nextDuelData['candidate_a'] as Map<String, dynamic>,
        ),
        candidateB: Candidate.fromJson(
          nextDuelData['candidate_b'] as Map<String, dynamic>,
        ),
        progress: progress,
      );

      state = state.copyWith(
        currentDuel: nextDuel,
        isVoting: false,
        clearLastVoted: true,
      );
    } catch (e) {
      state = state.copyWith(
        isVoting: false,
        error: e.toString(),
        clearLastVoted: true,
      );
    }
  }

  Future<void> _queueOfflineVote({
    required int candidateAId,
    required int candidateBId,
    int? winnerId,
  }) async {
    await HiveCache.addPendingVote({
      'election_uuid': _electionUuid,
      'candidate_a_id': candidateAId,
      'candidate_b_id': candidateBId,
      'winner_id': winnerId,
      'timestamp': DateTime.now().toIso8601String(),
    });
  }

  /// Retry after an error
  Future<void> retry() async {
    if (state.currentDuel != null) {
      // Just clear the error
      state = state.copyWith(clearError: true);
    } else {
      // Reload the duel
      await loadNextDuel();
    }
  }

  /// Clear error
  void clearError() {
    state = state.copyWith(clearError: true);
  }
}

// Voting provider (family by election UUID)
final votingProvider =
    StateNotifierProvider.family<VotingNotifier, VotingState, String>(
  (ref, uuid) => VotingNotifier(ref, uuid),
);

// Vote history provider
final voteHistoryProvider = FutureProvider.family<List<VoteHistory>, String>(
  (ref, electionUuid) async {
    final apiClient = ref.read(apiClientProvider);
    final response = await apiClient.get<Map<String, dynamic>>(
      '/elections/$electionUuid/vote/history',
    );
    final data = response['data'] as List;
    return data
        .map((e) => VoteHistory.fromJson(e as Map<String, dynamic>))
        .toList();
  },
);

// Pending votes count provider (for offline indicator)
final pendingVotesCountProvider = Provider<int>((ref) {
  return HiveCache.getPendingVotes().length;
});

// Sync pending votes (call when coming online)
Future<void> syncPendingVotes(Ref ref) async {
  final apiClient = ref.read(apiClientProvider);
  final pendingVotes = HiveCache.getPendingVotes();

  for (var i = 0; i < pendingVotes.length; i++) {
    final vote = pendingVotes[i];
    try {
      await apiClient.post(
        '/elections/${vote['election_uuid']}/vote',
        data: {
          'candidate_a_id': vote['candidate_a_id'],
          'candidate_b_id': vote['candidate_b_id'],
          'winner_id': vote['winner_id'],
        },
      );
      await HiveCache.removePendingVote(i);
    } catch (_) {
      // Keep the vote in queue for next sync
      break;
    }
  }
}
```

**Step 2: Commit**

```bash
cd /Users/lounis/dev/ScreenBuddies
git add frontend/lib/presentation/providers/voting_provider.dart
git commit -m "feat: add voting provider with offline queue"
```

---

## API Endpoints

**GET /elections/{uuid}/vote/next**

Response (has duel):
```json
{
  "data": {
    "candidate_a": { "id": 1, "title": "Movie A", ... },
    "candidate_b": { "id": 2, "title": "Movie B", ... },
    "progress": { "completed": 5, "total": 15, "percentage": 33.3 }
  }
}
```

Response (complete):
```json
{
  "data": null
}
```

**POST /elections/{uuid}/vote**

Request:
```json
{
  "candidate_a_id": 1,
  "candidate_b_id": 2,
  "winner_id": 1
}
```

Response:
```json
{
  "data": {
    "voted": true,
    "next_duel": {
      "candidate_a": { ... },
      "candidate_b": { ... }
    },
    "progress": { "completed": 6, "total": 15, "percentage": 40.0 }
  }
}
```

---

## Usage Example

```dart
// In a widget
final votingState = ref.watch(votingProvider(electionUuid));
final votingNotifier = ref.read(votingProvider(electionUuid).notifier);

// Vote for candidate A
votingNotifier.vote(votingState.currentDuel!.candidateA.id);

// Skip current duel
votingNotifier.skip();

// Check if complete
if (votingState.isComplete) {
  // Navigate to results
}
```

---

## Phase 6.4 Completion Checklist

- [ ] voting_provider.dart created
- [ ] VotingState with currentDuel, progress, loading states
- [ ] VotingNotifier with loadNextDuel(), vote(), skip()
- [ ] Offline vote queuing (HiveCache)
- [ ] voteHistoryProvider for viewing past votes
- [ ] pendingVotesCountProvider for offline indicator
- [ ] syncPendingVotes() function for sync
- [ ] All changes committed

---

## Next Sub-Phase

Proceed to **Phase 6.5: Election Widgets** for reusable UI components.
