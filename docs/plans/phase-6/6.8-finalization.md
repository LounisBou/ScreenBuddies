# Phase 6.8: Finalization

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Complete Phase 6 by updating router with election routes and running integration tests.

**Architecture:** GoRouter route additions, manual integration testing checklist.

**Tech Stack:** Flutter, GoRouter

**Prerequisites:** Phase 6.7 complete

**Reference:** `docs/plans/phase-6-flutter-election-features.md` Task 9

---

## Task 1: Update Router with Election Routes

**Step 1: Update router.dart**

Modify `frontend/lib/presentation/router/router.dart` to add election routes:

Add imports at top:
```dart
import '../screens/election/duel_screen.dart';
```

Add routes inside the authenticated ShellRoute children array (after home route):
```dart
// Election detail route
GoRoute(
  path: '/election/:uuid',
  name: AppRoutes.electionDetail,
  builder: (context, state) {
    final uuid = state.pathParameters['uuid']!;
    return ElectionDetailScreen(electionUuid: uuid);
  },
  routes: [
    // Voting/Duel route
    GoRoute(
      path: 'vote',
      name: AppRoutes.electionVote,
      builder: (context, state) {
        final uuid = state.pathParameters['uuid']!;
        return DuelScreen(electionUuid: uuid);
      },
    ),
    // Results route (placeholder for Phase 7)
    GoRoute(
      path: 'results',
      name: AppRoutes.electionResults,
      builder: (context, state) {
        final uuid = state.pathParameters['uuid']!;
        return Scaffold(
          appBar: AppBar(title: const Text('Results')),
          body: Center(child: Text('Results for $uuid - Coming in Phase 7')),
        );
      },
    ),
  ],
),

// Create election route
GoRoute(
  path: '/election/create',
  name: AppRoutes.createElection,
  builder: (context, state) => const Scaffold(
    appBar: AppBar(title: Text('Create Election')),
    body: Center(child: Text('Create Election - Coming in Phase 7')),
  ),
),
```

**Step 2: Update AppRoutes constants**

Modify `frontend/lib/presentation/router/app_routes.dart` to add new route names:

```dart
class AppRoutes {
  static const splash = 'splash';
  static const login = 'login';
  static const register = 'register';
  static const home = 'home';
  static const profile = 'profile';

  // Election routes
  static const electionDetail = 'election-detail';
  static const electionVote = 'election-vote';
  static const electionResults = 'election-results';
  static const createElection = 'create-election';
}
```

**Step 3: Commit**

```bash
cd /Users/lounis/dev/ScreenBuddies
git add frontend/lib/presentation/router/
git commit -m "feat: add election routes to router"
```

---

## Task 2: Create ElectionDetailScreen Placeholder

**Step 1: Create election_detail_screen.dart**

Create `frontend/lib/presentation/screens/election/election_detail_screen.dart`:
```dart
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:go_router/go_router.dart';
import '../../../core/theme/app_colors.dart';
import '../../providers/elections_provider.dart';
import '../../widgets/common/offline_banner.dart';

class ElectionDetailScreen extends ConsumerWidget {
  final String electionUuid;

  const ElectionDetailScreen({
    super.key,
    required this.electionUuid,
  });

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final electionAsync = ref.watch(electionDetailProvider(electionUuid));

    return Scaffold(
      appBar: AppBar(
        title: const Text('Election Details'),
      ),
      body: Column(
        children: [
          const OfflineBanner(),
          Expanded(
            child: electionAsync.when(
              data: (election) => _buildContent(context, election),
              loading: () => const Center(child: CircularProgressIndicator()),
              error: (error, _) => Center(
                child: Column(
                  mainAxisAlignment: MainAxisAlignment.center,
                  children: [
                    Icon(Icons.error_outline, size: 48, color: AppColors.error),
                    const SizedBox(height: 16),
                    Text('Error: $error'),
                    const SizedBox(height: 16),
                    ElevatedButton(
                      onPressed: () => ref.invalidate(electionDetailProvider(electionUuid)),
                      child: const Text('Retry'),
                    ),
                  ],
                ),
              ),
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildContent(BuildContext context, ElectionDetail election) {
    return SingleChildScrollView(
      padding: const EdgeInsets.all(16),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          // Election title
          Text(
            election.title,
            style: Theme.of(context).textTheme.headlineMedium?.copyWith(
                  fontWeight: FontWeight.bold,
                ),
          ),
          const SizedBox(height: 8),

          // Status badge placeholder
          Container(
            padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 4),
            decoration: BoxDecoration(
              color: AppColors.primary.withOpacity(0.1),
              borderRadius: BorderRadius.circular(16),
            ),
            child: Text(
              election.status.toUpperCase(),
              style: TextStyle(
                color: AppColors.primary,
                fontWeight: FontWeight.bold,
                fontSize: 12,
              ),
            ),
          ),
          const SizedBox(height: 16),

          // Description
          if (election.description != null) ...[
            Text(
              election.description!,
              style: Theme.of(context).textTheme.bodyMedium?.copyWith(
                    color: AppColors.textSecondary,
                  ),
            ),
            const SizedBox(height: 24),
          ],

          // Candidates count
          Card(
            child: ListTile(
              leading: const Icon(Icons.movie_outlined),
              title: Text('${election.candidatesCount} Candidates'),
              subtitle: const Text('Media items to vote on'),
            ),
          ),
          const SizedBox(height: 8),

          // Voters count
          Card(
            child: ListTile(
              leading: const Icon(Icons.people_outlined),
              title: Text('${election.votersCount} Voters'),
              subtitle: const Text('Participants in this election'),
            ),
          ),
          const SizedBox(height: 24),

          // Action buttons
          if (election.status == 'voting') ...[
            SizedBox(
              width: double.infinity,
              child: ElevatedButton.icon(
                onPressed: () => context.push('/election/$electionUuid/vote'),
                icon: const Icon(Icons.how_to_vote),
                label: const Text('Start Voting'),
              ),
            ),
          ],

          if (election.status == 'ended') ...[
            SizedBox(
              width: double.infinity,
              child: ElevatedButton.icon(
                onPressed: () => context.push('/election/$electionUuid/results'),
                icon: const Icon(Icons.bar_chart),
                label: const Text('View Results'),
              ),
            ),
          ],

          const SizedBox(height: 16),
          Center(
            child: Text(
              'Full election management coming in Phase 7',
              style: Theme.of(context).textTheme.bodySmall?.copyWith(
                    color: AppColors.textSecondary,
                  ),
            ),
          ),
        ],
      ),
    );
  }
}
```

**Step 2: Create screens/election directory if needed and add export**

Create directory structure:
```bash
mkdir -p frontend/lib/presentation/screens/election
```

**Step 3: Commit**

```bash
cd /Users/lounis/dev/ScreenBuddies
git add frontend/lib/presentation/screens/election/
git commit -m "feat: add election detail screen placeholder"
```

---

## Task 3: Manual Integration Testing

**Step 1: Run the app**

```bash
cd /Users/lounis/dev/ScreenBuddies/frontend
flutter run
```

**Step 2: Test checklist**

Verify the following manually:

### Authentication Flow
- [ ] App starts at splash screen
- [ ] Redirects to login if not authenticated
- [ ] Can register new account
- [ ] Can login with existing account
- [ ] Logout returns to login screen

### Home Screen
- [ ] Shows "Verify Email" state if email not verified
- [ ] Shows "No Elections Yet" if no elections exist
- [ ] Shows elections list when elections exist
- [ ] Pull-to-refresh works
- [ ] Offline banner appears when offline
- [ ] "Last updated" text shows cache timestamp

### Election Detail
- [ ] Tapping election card navigates to detail screen
- [ ] Detail screen shows election info
- [ ] "Start Voting" button appears for voting status
- [ ] "View Results" button appears for ended status

### Voting Flow
- [ ] DuelScreen loads first duel
- [ ] Tapping candidate selects it (animation)
- [ ] "Vote" button submits vote
- [ ] "Skip" button skips duel
- [ ] Progress indicator updates
- [ ] Complete screen shows when all duels done
- [ ] Back navigation works

### Offline Behavior
- [ ] Enable airplane mode
- [ ] Cached elections still display
- [ ] Offline banner visible
- [ ] Vote attempt shows "queued" message
- [ ] Disable airplane mode
- [ ] Refresh loads fresh data

**Step 3: Fix any issues found**

Document and fix any bugs discovered during testing.

**Step 4: Final commit**

```bash
cd /Users/lounis/dev/ScreenBuddies
git add -A
git commit -m "test: complete Phase 6 integration testing"
```

---

## Phase 6 Final Completion Checklist

### Data Models (6.1)
- [ ] MediaType enum
- [ ] Candidate model with fromJson
- [ ] MediaItem model for search
- [ ] Election model with fromJson
- [ ] ElectionDetail model
- [ ] Maestro model
- [ ] Voter model
- [ ] Duel and DuelProgress models

### Elections Provider (6.2)
- [ ] ElectionsState with loading/error states
- [ ] ElectionsNotifier with CRUD operations
- [ ] electionDetailProvider (family)
- [ ] Offline caching with HiveCache
- [ ] myElectionsProvider derived
- [ ] participatingElectionsProvider derived

### Media Search Provider (6.3)
- [ ] MediaSearchState with pagination
- [ ] MediaSearchNotifier with debounce
- [ ] loadMore() for infinite scroll
- [ ] mediaTypesProvider

### Voting Provider (6.4)
- [ ] VotingState with currentDuel
- [ ] VotingNotifier with vote/skip
- [ ] Offline vote queuing
- [ ] voteHistoryProvider
- [ ] pendingVotesCountProvider
- [ ] syncPendingVotes function

### Election Widgets (6.5)
- [ ] ElectionStatusBadge
- [ ] ElectionCard
- [ ] OfflineBanner
- [ ] LastUpdatedText
- [ ] CandidateCard

### Home Screen (6.6)
- [ ] Elections list with sections
- [ ] Offline banner integration
- [ ] Email verification state
- [ ] Empty state
- [ ] Error state with retry
- [ ] Pull-to-refresh

### Duel Screen (6.7)
- [ ] DuelCard with selection
- [ ] Vote/Skip buttons
- [ ] Progress indicator
- [ ] Complete state
- [ ] Error handling

### Router & Integration (6.8)
- [ ] Election routes added
- [ ] ElectionDetailScreen
- [ ] Manual testing complete

---

## What's Next

Phase 6 provides the core election viewing and voting experience. Future phases will add:

**Phase 7 (Future):**
- Create/Edit election screens
- Candidate management (add/remove media)
- Invite voters (share link)
- Results visualization (rankings, graphs)
- Real-time updates (WebSocket/polling)

**Phase 8 (Future):**
- Push notifications
- Deep linking
- App store preparation
- Performance optimization

---

## Notes for Implementation

1. **API Contract**: Ensure backend endpoints match the expected request/response formats documented in each sub-phase.

2. **Error Messages**: Backend should return user-friendly error messages that can be displayed directly.

3. **Offline First**: The caching strategy assumes read-only offline support. Writes (votes) are queued and synced when online.

4. **Testing**: Each sub-phase includes unit test patterns. Integration tests should cover the flows in the manual testing checklist.

5. **Accessibility**: All widgets should include semantic labels for screen readers. This can be enhanced in future iterations.
