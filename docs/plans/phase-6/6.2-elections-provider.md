# Phase 6.2: Elections Provider

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Create Riverpod provider for elections list and election creation.

**Architecture:** StateNotifier for elections list, FutureProvider.family for election details.

**Tech Stack:** Riverpod 2.x, Dio

**Prerequisites:** Phase 6.1 complete

**Reference:** `docs/plans/phase-6-flutter-election-features.md` Task 2

---

## Task 1: Create Elections Provider

**Step 1: Create elections_provider.dart**

Create `frontend/lib/presentation/providers/elections_provider.dart`:
```dart
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../../data/cache/hive_cache.dart';
import '../../data/models/candidate_model.dart';
import '../../data/models/election_model.dart';
import '../../core/services/connectivity_service.dart';
import 'auth_provider.dart';

// Elections list state
class ElectionsState {
  final List<Election> elections;
  final bool isLoading;
  final bool isRefreshing;
  final String? error;
  final DateTime? cachedAt;

  const ElectionsState({
    this.elections = const [],
    this.isLoading = false,
    this.isRefreshing = false,
    this.error,
    this.cachedAt,
  });

  bool get isEmpty => elections.isEmpty && !isLoading;
  bool get hasError => error != null;

  ElectionsState copyWith({
    List<Election>? elections,
    bool? isLoading,
    bool? isRefreshing,
    String? error,
    bool clearError = false,
    DateTime? cachedAt,
  }) {
    return ElectionsState(
      elections: elections ?? this.elections,
      isLoading: isLoading ?? this.isLoading,
      isRefreshing: isRefreshing ?? this.isRefreshing,
      error: clearError ? null : (error ?? this.error),
      cachedAt: cachedAt ?? this.cachedAt,
    );
  }
}

// Elections notifier
class ElectionsNotifier extends StateNotifier<ElectionsState> {
  final Ref _ref;

  ElectionsNotifier(this._ref) : super(const ElectionsState()) {
    _loadInitial();
  }

  Future<void> _loadInitial() async {
    // First, try to load from cache
    final cachedData = HiveCache.getCachedElections();
    final cachedAt = HiveCache.getElectionsCachedAt();

    if (cachedData != null) {
      final elections = cachedData
          .map((e) => Election.fromJson(e))
          .toList();
      state = state.copyWith(
        elections: elections,
        cachedAt: cachedAt,
      );
    }

    // Then try to refresh from network
    await loadElections();
  }

  Future<void> loadElections({bool forceRefresh = false}) async {
    final isOnline = await _ref.read(connectivityServiceProvider).isOnline;

    // If offline and we have cache, don't show loading
    if (!isOnline && state.elections.isNotEmpty) {
      return;
    }

    state = state.copyWith(
      isLoading: state.elections.isEmpty,
      isRefreshing: state.elections.isNotEmpty,
      clearError: true,
    );

    try {
      final apiClient = _ref.read(apiClientProvider);
      final response = await apiClient.get<Map<String, dynamic>>('/elections');
      final data = response['data'] as List;
      final elections = data
          .map((e) => Election.fromJson(e as Map<String, dynamic>))
          .toList();

      // Cache the results
      await HiveCache.cacheElections(
        data.cast<Map<String, dynamic>>(),
      );

      state = state.copyWith(
        elections: elections,
        isLoading: false,
        isRefreshing: false,
        cachedAt: DateTime.now(),
      );
    } catch (e) {
      // If we have cached data, just show error notification
      // Otherwise, show error in UI
      state = state.copyWith(
        isLoading: false,
        isRefreshing: false,
        error: state.elections.isEmpty ? e.toString() : null,
      );
    }
  }

  Future<ElectionDetail> createElection({
    required String title,
    String? description,
    required String mediaTypeCode,
    required int winnerCount,
    required DateTime electionDate,
    required DateTime deadline,
    DateTime? campaignEnd,
    bool allowSuggestions = false,
    bool autoApprove = false,
    required List<MediaItem> candidates,
  }) async {
    final apiClient = _ref.read(apiClientProvider);

    final response = await apiClient.post<Map<String, dynamic>>(
      '/elections',
      data: {
        'title': title,
        'description': description,
        'media_type_code': mediaTypeCode,
        'winner_count': winnerCount,
        'election_date': electionDate.toIso8601String(),
        'deadline': deadline.toIso8601String(),
        if (campaignEnd != null) 'campaign_end': campaignEnd.toIso8601String(),
        'allow_suggestions': allowSuggestions,
        'auto_approve': autoApprove,
        'candidates': candidates
            .map((c) => {
                  'external_id': c.externalId,
                  'title': c.title,
                  'poster_url': c.posterUrl,
                  'year': c.year,
                  'metadata': c.metadata,
                })
            .toList(),
      },
    );

    final election = ElectionDetail.fromJson(
      response['data'] as Map<String, dynamic>,
    );

    // Refresh the list to include the new election
    await loadElections(forceRefresh: true);

    return election;
  }

  Future<void> deleteElection(String uuid) async {
    final apiClient = _ref.read(apiClientProvider);
    await apiClient.delete('/elections/$uuid');
    await loadElections(forceRefresh: true);
  }

  void clearError() {
    state = state.copyWith(clearError: true);
  }
}

// Main provider
final electionsProvider =
    StateNotifierProvider<ElectionsNotifier, ElectionsState>((ref) {
  return ElectionsNotifier(ref);
});

// Single election detail provider
final electionDetailProvider =
    FutureProvider.family<ElectionDetail, String>((ref, uuid) async {
  // First check cache
  final cached = HiveCache.getCachedElectionDetails(uuid);
  if (cached != null) {
    final isOnline = await ref.read(connectivityServiceProvider).isOnline;
    if (!isOnline) {
      return ElectionDetail.fromJson(cached);
    }
  }

  // Fetch fresh data
  final apiClient = ref.read(apiClientProvider);
  final response = await apiClient.get<Map<String, dynamic>>('/elections/$uuid');
  final data = response['data'] as Map<String, dynamic>;

  // Cache it
  await HiveCache.cacheElectionDetails(uuid, data);

  return ElectionDetail.fromJson(data);
});

// Convenience provider for user's elections where they are maestro
final myElectionsProvider = Provider<List<Election>>((ref) {
  final state = ref.watch(electionsProvider);
  return state.elections.where((e) => e.isMaestro).toList();
});

// Convenience provider for elections where user is voter only
final participatingElectionsProvider = Provider<List<Election>>((ref) {
  final state = ref.watch(electionsProvider);
  return state.elections.where((e) => !e.isMaestro).toList();
});
```

**Step 2: Commit**

```bash
cd /Users/lounis/dev/ScreenBuddies
git add frontend/lib/presentation/providers/elections_provider.dart
git commit -m "feat: add elections provider with caching"
```

---

## Task 2: Create Election Repository (Optional Abstraction)

**Step 1: Create election_repository.dart**

Create `frontend/lib/data/repositories/election_repository.dart`:
```dart
import '../models/election_model.dart';
import '../models/candidate_model.dart';

abstract class ElectionRepository {
  Future<List<Election>> getElections();
  Future<ElectionDetail> getElectionDetail(String uuid);
  Future<ElectionDetail> createElection({
    required String title,
    String? description,
    required String mediaTypeCode,
    required int winnerCount,
    required DateTime electionDate,
    required DateTime deadline,
    DateTime? campaignEnd,
    bool allowSuggestions,
    bool autoApprove,
    required List<MediaItem> candidates,
  });
  Future<void> deleteElection(String uuid);
  Future<void> joinElection(String inviteCode);
  Future<String> getInviteLink(String uuid);
}
```

**Step 2: Commit**

```bash
git add frontend/lib/data/repositories/election_repository.dart
git commit -m "feat: add election repository interface"
```

---

## API Endpoints

| Method | Endpoint | Description |
|--------|----------|-------------|
| GET | /elections | List user's elections |
| POST | /elections | Create new election |
| GET | /elections/{uuid} | Get election details |
| DELETE | /elections/{uuid} | Delete election (maestro only) |

---

## Create Election Payload

```json
{
  "title": "Movie Night",
  "description": "What should we watch?",
  "media_type_code": "movie",
  "winner_count": 1,
  "election_date": "2024-01-20T20:00:00Z",
  "deadline": "2024-01-20T18:00:00Z",
  "campaign_end": "2024-01-19T00:00:00Z",
  "allow_suggestions": false,
  "auto_approve": false,
  "candidates": [
    {
      "external_id": "tmdb:123",
      "title": "The Matrix",
      "poster_url": "https://...",
      "year": 1999,
      "metadata": {}
    }
  ]
}
```

---

## Phase 6.2 Completion Checklist

- [ ] elections_provider.dart created
- [ ] ElectionsState with elections, loading, error
- [ ] ElectionsNotifier with loadElections(), createElection()
- [ ] Cache integration (load from cache, update cache)
- [ ] Offline support (return cached data when offline)
- [ ] electionDetailProvider (FutureProvider.family)
- [ ] Convenience providers (myElections, participating)
- [ ] All changes committed

---

## Next Sub-Phase

Proceed to **Phase 6.3: Media Search Provider** for candidate search.
