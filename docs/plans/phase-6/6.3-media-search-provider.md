# Phase 6.3: Media Search Provider

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Create provider for searching media (movies, TV shows, games) to add as election candidates.

**Architecture:** StateNotifier with pagination support for search results.

**Tech Stack:** Riverpod 2.x, Dio

**Prerequisites:** Phase 6.2 complete

**Reference:** `docs/plans/phase-6-flutter-election-features.md` Task 3

---

## Task 1: Create Media Search Provider

**Step 1: Create media_search_provider.dart**

Create `frontend/lib/presentation/providers/media_search_provider.dart`:
```dart
import 'dart:async';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../../data/models/candidate_model.dart';
import 'auth_provider.dart';

// Search state
class MediaSearchState {
  final List<MediaItem> results;
  final bool isLoading;
  final bool isLoadingMore;
  final String? error;
  final int currentPage;
  final int totalPages;
  final int totalResults;
  final String lastQuery;
  final String lastType;

  const MediaSearchState({
    this.results = const [],
    this.isLoading = false,
    this.isLoadingMore = false,
    this.error,
    this.currentPage = 1,
    this.totalPages = 1,
    this.totalResults = 0,
    this.lastQuery = '',
    this.lastType = '',
  });

  bool get hasMore => currentPage < totalPages;
  bool get isEmpty => results.isEmpty && !isLoading;
  bool get hasResults => results.isNotEmpty;

  MediaSearchState copyWith({
    List<MediaItem>? results,
    bool? isLoading,
    bool? isLoadingMore,
    String? error,
    bool clearError = false,
    int? currentPage,
    int? totalPages,
    int? totalResults,
    String? lastQuery,
    String? lastType,
  }) {
    return MediaSearchState(
      results: results ?? this.results,
      isLoading: isLoading ?? this.isLoading,
      isLoadingMore: isLoadingMore ?? this.isLoadingMore,
      error: clearError ? null : (error ?? this.error),
      currentPage: currentPage ?? this.currentPage,
      totalPages: totalPages ?? this.totalPages,
      totalResults: totalResults ?? this.totalResults,
      lastQuery: lastQuery ?? this.lastQuery,
      lastType: lastType ?? this.lastType,
    );
  }
}

// Search notifier
class MediaSearchNotifier extends StateNotifier<MediaSearchState> {
  final Ref _ref;
  Timer? _debounceTimer;

  MediaSearchNotifier(this._ref) : super(const MediaSearchState());

  @override
  void dispose() {
    _debounceTimer?.cancel();
    super.dispose();
  }

  /// Search with debounce for real-time search
  void searchDebounced(String type, String query, {Duration delay = const Duration(milliseconds: 300)}) {
    _debounceTimer?.cancel();

    if (query.isEmpty) {
      clear();
      return;
    }

    _debounceTimer = Timer(delay, () {
      search(type, query);
    });
  }

  /// Immediate search
  Future<void> search(String type, String query) async {
    if (query.isEmpty) {
      clear();
      return;
    }

    state = state.copyWith(
      isLoading: true,
      clearError: true,
      lastQuery: query,
      lastType: type,
    );

    try {
      final apiClient = _ref.read(apiClientProvider);
      final response = await apiClient.get<Map<String, dynamic>>(
        '/media/search',
        queryParameters: {
          'type': type,
          'query': query,
          'page': 1,
        },
      );

      final data = response['data'] as List;
      final meta = response['meta'] as Map<String, dynamic>;

      final results = data
          .map((e) => MediaItem.fromJson(e as Map<String, dynamic>))
          .toList();

      state = state.copyWith(
        results: results,
        isLoading: false,
        currentPage: meta['current_page'] as int,
        totalPages: meta['total_pages'] as int,
        totalResults: meta['total'] as int? ?? results.length,
      );
    } catch (e) {
      state = state.copyWith(
        isLoading: false,
        error: e.toString(),
      );
    }
  }

  /// Load more results (pagination)
  Future<void> loadMore() async {
    if (state.isLoading || state.isLoadingMore || !state.hasMore) {
      return;
    }

    final nextPage = state.currentPage + 1;

    state = state.copyWith(isLoadingMore: true);

    try {
      final apiClient = _ref.read(apiClientProvider);
      final response = await apiClient.get<Map<String, dynamic>>(
        '/media/search',
        queryParameters: {
          'type': state.lastType,
          'query': state.lastQuery,
          'page': nextPage,
        },
      );

      final data = response['data'] as List;
      final meta = response['meta'] as Map<String, dynamic>;

      final newResults = data
          .map((e) => MediaItem.fromJson(e as Map<String, dynamic>))
          .toList();

      state = state.copyWith(
        results: [...state.results, ...newResults],
        isLoadingMore: false,
        currentPage: meta['current_page'] as int,
        totalPages: meta['total_pages'] as int,
      );
    } catch (e) {
      state = state.copyWith(
        isLoadingMore: false,
        error: e.toString(),
      );
    }
  }

  /// Clear search results
  void clear() {
    _debounceTimer?.cancel();
    state = const MediaSearchState();
  }

  /// Clear error
  void clearError() {
    state = state.copyWith(clearError: true);
  }
}

// Main provider
final mediaSearchProvider =
    StateNotifierProvider<MediaSearchNotifier, MediaSearchState>((ref) {
  return MediaSearchNotifier(ref);
});

// Media types provider (fetch available types)
final mediaTypesProvider = FutureProvider<List<Map<String, String>>>((ref) async {
  final apiClient = ref.read(apiClientProvider);
  final response = await apiClient.get<Map<String, dynamic>>('/media/types');
  final data = response['data'] as List;
  return data
      .map((e) => {
            'code': e['code'] as String,
            'label': e['label'] as String,
          })
      .toList();
});
```

**Step 2: Commit**

```bash
cd /Users/lounis/dev/ScreenBuddies
git add frontend/lib/presentation/providers/media_search_provider.dart
git commit -m "feat: add media search provider with pagination"
```

---

## API Endpoint

**GET /media/search**

Query Parameters:
- `type`: Media type code (movie, tvshow, videogame)
- `query`: Search query string
- `page`: Page number (default: 1)

Response:
```json
{
  "data": [
    {
      "external_id": "tmdb:123",
      "title": "The Matrix",
      "poster_url": "https://image.tmdb.org/t/p/w500/...",
      "year": 1999,
      "metadata": {
        "overview": "A computer hacker learns...",
        "vote_average": 8.2
      }
    }
  ],
  "meta": {
    "current_page": 1,
    "total_pages": 10,
    "total": 195,
    "per_page": 20
  }
}
```

---

## Usage Example

```dart
// In a widget
final searchState = ref.watch(mediaSearchProvider);
final searchNotifier = ref.read(mediaSearchProvider.notifier);

// Search with debounce (for TextField onChanged)
TextField(
  onChanged: (value) {
    searchNotifier.searchDebounced('movie', value);
  },
)

// Load more (for infinite scroll)
if (searchState.hasMore && !searchState.isLoadingMore) {
  searchNotifier.loadMore();
}

// Clear search
searchNotifier.clear();
```

---

## Phase 6.3 Completion Checklist

- [ ] media_search_provider.dart created
- [ ] MediaSearchState with results, pagination info
- [ ] MediaSearchNotifier with search(), loadMore(), clear()
- [ ] Debounced search for real-time search
- [ ] Pagination support (hasMore, loadMore)
- [ ] mediaTypesProvider for available types
- [ ] All changes committed

---

## Next Sub-Phase

Proceed to **Phase 6.4: Voting Provider** for duel and vote management.
